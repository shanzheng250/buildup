OOM问题解决方案

jps -l 查看java pid
jstat -gc PID查看gc情况
jmap -F -dump:format=b,file=a.txt  堆内存dump出来
然后用MAT分析一下


java虚拟机的内存结构

1、程序计数器
    用来线程切换时，线程执行的指令位置
    每个线程独有的内存空间

2、虚拟机栈
    用来存储方法的局部变量、部分结果   局部变量越多则出现oom的可能性越大
    每个线程独有的内存空间
    OOM问题
        a）栈固定大小 会导致stackoverflow。 一般是请求栈深度超过设置。exp：递归调用、cglib操作
        b) 栈动态大小 会导致oom  一般是动态扩展导致 没有足够的内存来进行拓展
    优化方法 : -Xss

3、本地方法栈
    不是java实现的，和虚拟机栈类似，但是在hotpot虚拟机里面是一个东西

4、堆
    用来存储对象和数组，分为新生代和老年代，新生代分为eden和survivour
    所有线程共用
    OOM问题
    优化方法 -Xms 最小堆内存 设置不合理会导致频繁GC
             -Xmx 最大堆内存
             -Xmn 新生代的内存 实际上是-XX:NewSize ===  -XX:MaxNewSize的写法

5、 方法区  1.7 实现是永久区 1.8实现是元空间
    类信息、常理池、修饰符、方法信息等等
    所有线程共用
    OOM问题
        创建大量string
     优化方法 -XX:PermSize 持久带内存 设置不合理会导致频繁GC


垃圾回收算法
    1、引用计数法
        引用一次记录一次
        无法解决循环引用的问题
    2、标记清除法
        从根节点可达就标识，否则回收
        内存碎片
    3、复制
        分为两块，在A垃圾回收时，把A放入B中，这样内存连续速度快（新生代）  存活少 垃圾多
    4、标记整理
        标记清除法的优化，内存连续 （年老代）

垃圾回收器的分类
    1、按照线程数
        串行和并行
    2、工作模式
        并发和独占

新生代串行 独占  复制算法
    会导致stop the world

老年代串行 独占  标记压缩 -- 标记整理

新生代并行收集器  ps （parallel scvenge） 关注吞吐量

cms 并发标记清除 concurrent mark swap
    不独占，不会使程序停顿
    劣势：标记清除导致大量内存碎片
    并行处理导致系统吞吐量下降

G1 标记压缩算法，吞吐量和停顿控制优化



stop the world 一般是指独占式垃圾回收器，暂停应用程序直到垃圾回收结束


top 查看cup
iostat 查看io

















